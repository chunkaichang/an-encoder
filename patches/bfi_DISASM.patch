diff --git a/bfi.cpp b/bfi.cpp
--- a/bfi.cpp
+++ b/bfi.cpp
@@ -31,6 +31,10 @@
 #include <cassert>
 #include "pin.H"
 
+#ifdef DISASM
+  #include <map>
+#endif /* DISASM */
+
 /* ----------------------------------------------------------------------------
  * types
  * ------------------------------------------------------------------------- */
@@ -167,7 +171,16 @@
         vfprintf(stderr, bfmt, ap);
         va_end(ap);
     }
-
+#ifdef DISASM
+/* NOTE: If disassembling is switched on, disassembled instructions are dumped
+   to <stdout> as they are executed. Hence we duplicate the output from calls
+   to 'info' to <stdout> so that it can be seen where (or rather, when) in
+   the instruction stream faults were injected. */
+    va_list ap;
+    va_start(ap, fmt);
+    vfprintf(stdout, bfmt, ap);
+    va_end(ap);
+#endif /* DISASM */
     // breakpoint in debugger (if connected)
     if (ctx) PIN_ApplicationBreakpoint(ctx, id, FALSE, "fault injected");
 }
@@ -214,6 +227,36 @@
     if (detach) PIN_Detach();
 }
 
+#ifdef DISASM
+std::map<ADDRINT,std::string> assembly;
+
+/* NOTE: Disassembled instructions are dumped to <stdout>. This is because
+   output to <stderr> is trawled by the Python script "coverage.py". Hence
+   output to <stderr> should be kept small in order to reduce the runtime
+   of "coverage.py". */
+static VOID
+disasm(THREADID id, CONTEXT* ctx, ADDRINT ip, UINT32 size)
+{
+    if (!right_thread(id)) return;
+
+    ADDRINT reg_ip = (ADDRINT) PIN_GetContextReg(ctx, REG_INST_PTR);
+    fprintf(stdout, "0x%lX (ip=0x%lX): (size=%d) ", ip, reg_ip, size);
+    unsigned char *addr = (unsigned char*)ip;
+    for (unsigned i = 0; i < size; i++)
+      fprintf(stdout, "%02X.", addr[i]);
+    fprintf(stdout, " %s\n", assembly[ip].c_str());
+}
+
+static VOID
+targetname(THREADID id, CONTEXT* ctx, ADDRINT target)
+{
+    if (!right_thread(id)) return;
+	
+	std::string name = RTN_FindNameByAddress(target);    
+	fprintf(stdout, "name of target at address 0x%lX: %s\n", target, name.c_str());
+}
+#endif /* DISASM */
+
 /* ----------------------------------------------------------------------------
  * count and find functions
  * ------------------------------------------------------------------------- */
@@ -473,6 +516,24 @@
 static VOID
 instrument_count(INS ins, VOID* v)
 {
+#ifdef DISASM
+    assembly[INS_Address(ins)] = INS_Disassemble(ins);
+    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) disasm,
+                   IARG_THREAD_ID,
+                   IARG_CONTEXT,
+                   IARG_ADDRINT, INS_Address(ins),
+                   IARG_UINT32, INS_Size(ins),
+                   IARG_END);
+    if (INS_IsDirectBranchOrCall(ins)) {
+        ADDRINT target = INS_DirectBranchOrCallTargetAddress(ins);
+    	INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) targetname,
+                       IARG_THREAD_ID,
+                       IARG_CONTEXT,
+                       IARG_ADDRINT, target,
+                       IARG_END);
+    }
+#endif /* DISASM */
+
     // count instructions
     INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) count_instr,
                    IARG_THREAD_ID,
